# 개미 전사 (p.220)

# 다이나믹 프로그래밍의 핵심은 DP 테이블인 듯
# 캐싱하는 방법에 대해 조금 더 고민해 볼 것

n = int(input())
warehouses = list(map(int, input().split()))

# DP 테이블
# i번 창고를 털었을 때 가질 수 있는 최댓값을 d[i]에 저장
d = [0] * 100

# 0번 창고 기준: 왼쪽으로 창고가 더 이상 없으므로 0번 창고의 식량만 더해 주기
d[0] = warehouses[0]
# 1번 창고 기준: 현재 창고를 기준으로 인접한 두 창고를 털 수 없으므로 현재 창고(1)와 0번 창고 중 하나를 선택했을 때
#              최대한 식량을 털 수 있는 경우를 선택
d[1] = max(warehouses[0], warehouses[1])

# 2번 창고부터는 앞서 행했던 과정들이 반복적으로 더해짐
for i in range(2, n):
    # (i - 1)번째 창고를 털었을 때의 최댓값, ((i - 2)번째 창고를 털었을 때의 최댓값 + 현재 창고 식량 수)를 비교
    d[i] = max(d[i - 1], d[i - 2] + warehouses[i])
    
print(d[n - 1])
